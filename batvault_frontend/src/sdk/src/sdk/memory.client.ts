/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * BatVault Memory_API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import axios from 'axios'
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
export type ResolveTextApiResolveTextPostBody = { [key: string]: unknown };

export type ExpandCandidatesApiGraphExpandCandidatesPostBody = { [key: string]: unknown };

export type EnrichEventApiEnrichEventGetParams = {
anchor: string;
};

export type EnrichBatchApiEnrichBatchPostBody = { [key: string]: unknown };

export type EnrichHeadApiEnrichHeadParams = {
anchor: string;
};

export type EnrichApiEnrichGetParams = {
anchor: string;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}





/**
 * Type-agnostic enrich: lookup by anchor (Decision, Event, future types).
Snapshot policy: STRICT ‚Äî requires X-Snapshot-ETag matching the current snapshot; missing/mismatch ‚Üí 412.
Headers: mirrors x-snapshot-etag and X-BV-Policy-Fingerprint; does NOT set X-BV-Graph-FP (no graph in the payload).
Contract: returns a single masked node plus mask_summary.
 * @summary Enrich
 */
export const enrichApiEnrichGet = (
    params: EnrichApiEnrichGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `/api/enrich`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getEnrichApiEnrichGetQueryKey = (params: EnrichApiEnrichGetParams,) => {
    return [`/api/enrich`, ...(params ? [params]: [])] as const;
    }

    
export const getEnrichApiEnrichGetQueryOptions = <TData = Awaited<ReturnType<typeof enrichApiEnrichGet>>, TError = AxiosError<HTTPValidationError>>(params: EnrichApiEnrichGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enrichApiEnrichGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEnrichApiEnrichGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof enrichApiEnrichGet>>> = ({ signal }) => enrichApiEnrichGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof enrichApiEnrichGet>>, TError, TData> & { queryKey: QueryKey }
}

export type EnrichApiEnrichGetQueryResult = NonNullable<Awaited<ReturnType<typeof enrichApiEnrichGet>>>
export type EnrichApiEnrichGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Enrich
 */
export const useEnrichApiEnrichGet = <TData = Awaited<ReturnType<typeof enrichApiEnrichGet>>, TError = AxiosError<HTTPValidationError>>(
 params: EnrichApiEnrichGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enrichApiEnrichGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getEnrichApiEnrichGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Cheap freshness check: returns only ETag (quoted) and x-snapshot-etag; no body.
No snapshot precondition required. Use If-None-Match with the quoted ETag to get 304.
 * @summary Enrich Head
 */
export const enrichHeadApiEnrichHead = (
    params: EnrichHeadApiEnrichHeadParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.head(
      `/api/enrich`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }



export const getEnrichHeadApiEnrichHeadMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enrichHeadApiEnrichHead>>, TError,{params: EnrichHeadApiEnrichHeadParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof enrichHeadApiEnrichHead>>, TError,{params: EnrichHeadApiEnrichHeadParams}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enrichHeadApiEnrichHead>>, {params: EnrichHeadApiEnrichHeadParams}> = (props) => {
          const {params} = props ?? {};

          return  enrichHeadApiEnrichHead(params,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnrichHeadApiEnrichHeadMutationResult = NonNullable<Awaited<ReturnType<typeof enrichHeadApiEnrichHead>>>
    
    export type EnrichHeadApiEnrichHeadMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Enrich Head
 */
export const useEnrichHeadApiEnrichHead = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enrichHeadApiEnrichHead>>, TError,{params: EnrichHeadApiEnrichHeadParams}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof enrichHeadApiEnrichHead>>,
        TError,
        {params: EnrichHeadApiEnrichHeadParams},
        TContext
      > => {

      const mutationOptions = getEnrichHeadApiEnrichHeadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Enrich a bounded set of node IDs for short-answer composition.
Contract (Baseline v3, snapshot-bound):
  - Input: {"anchor_id": "<domain#id>", "snapshot_etag": "<etag>", "ids": ["..."]}
  - Policy: honour the same policy headers as /api/enrich; ACL-guard each item.
  - Scope safety: Memory recomputes the authorized set from the snapshot_etag/policy and
    **denies the whole call** if `requested_ids ‚äÑ allowed_ids` (default 403; optional 404 via x-denied-status).
  - Precondition: snapshot_etag is REQUIRED (body or X-Snapshot-ETag); missing/mismatch ‚Üí 412.
  - Output on success: {"items": {"<id>": {...masked enriched node...}, ...}} with minimal meta.
 * @summary Enrich Batch
 */
export const enrichBatchApiEnrichBatchPost = (
    enrichBatchApiEnrichBatchPostBody: EnrichBatchApiEnrichBatchPostBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.post(
      `/api/enrich/batch`,
      enrichBatchApiEnrichBatchPostBody,options
    );
  }



export const getEnrichBatchApiEnrichBatchPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enrichBatchApiEnrichBatchPost>>, TError,{data: EnrichBatchApiEnrichBatchPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof enrichBatchApiEnrichBatchPost>>, TError,{data: EnrichBatchApiEnrichBatchPostBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof enrichBatchApiEnrichBatchPost>>, {data: EnrichBatchApiEnrichBatchPostBody}> = (props) => {
          const {data} = props ?? {};

          return  enrichBatchApiEnrichBatchPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EnrichBatchApiEnrichBatchPostMutationResult = NonNullable<Awaited<ReturnType<typeof enrichBatchApiEnrichBatchPost>>>
    export type EnrichBatchApiEnrichBatchPostMutationBody = EnrichBatchApiEnrichBatchPostBody
    export type EnrichBatchApiEnrichBatchPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Enrich Batch
 */
export const useEnrichBatchApiEnrichBatchPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof enrichBatchApiEnrichBatchPost>>, TError,{data: EnrichBatchApiEnrichBatchPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof enrichBatchApiEnrichBatchPost>>,
        TError,
        {data: EnrichBatchApiEnrichBatchPostBody},
        TContext
      > => {

      const mutationOptions = getEnrichBatchApiEnrichBatchPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Event-only enrich by anchor.
Snapshot policy: STRICT ‚Äî same as /api/enrich (requires X-Snapshot-ETag).
Headers: mirrors x-snapshot-etag and X-BV-Policy-Fingerprint; does NOT set X-BV-Graph-FP.
 * @summary Enrich Event
 */
export const enrichEventApiEnrichEventGet = (
    params: EnrichEventApiEnrichEventGetParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `/api/enrich/event`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getEnrichEventApiEnrichEventGetQueryKey = (params: EnrichEventApiEnrichEventGetParams,) => {
    return [`/api/enrich/event`, ...(params ? [params]: [])] as const;
    }

    
export const getEnrichEventApiEnrichEventGetQueryOptions = <TData = Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>, TError = AxiosError<HTTPValidationError>>(params: EnrichEventApiEnrichEventGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEnrichEventApiEnrichEventGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>> = ({ signal }) => enrichEventApiEnrichEventGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>, TError, TData> & { queryKey: QueryKey }
}

export type EnrichEventApiEnrichEventGetQueryResult = NonNullable<Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>>
export type EnrichEventApiEnrichEventGetQueryError = AxiosError<HTTPValidationError>

/**
 * @summary Enrich Event
 */
export const useEnrichEventApiEnrichEventGet = <TData = Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>, TError = AxiosError<HTTPValidationError>>(
 params: EnrichEventApiEnrichEventGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof enrichEventApiEnrichEventGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getEnrichEventApiEnrichEventGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Edges-only graph view around the anchor (k=1).
Snapshot policy: STRICT ‚Äî requires X-Snapshot-ETag (or `snapshot_etag` in body); missing/mismatch ‚Üí 412. Mirrors x-snapshot-etag in responses for cache keys.
Headers: sets X-BV-Graph-FP and mirrors X-BV-Policy-Fingerprint (graph fingerprint also present at meta.fingerprints.graph_fp).
Contract: meta.fingerprints ONLY contains graph_fp; bundle_fp is never present here.
 * @summary Expand Candidates
 */
export const expandCandidatesApiGraphExpandCandidatesPost = (
    expandCandidatesApiGraphExpandCandidatesPostBody: ExpandCandidatesApiGraphExpandCandidatesPostBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.post(
      `/api/graph/expand_candidates`,
      expandCandidatesApiGraphExpandCandidatesPostBody,options
    );
  }



export const getExpandCandidatesApiGraphExpandCandidatesPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof expandCandidatesApiGraphExpandCandidatesPost>>, TError,{data: ExpandCandidatesApiGraphExpandCandidatesPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof expandCandidatesApiGraphExpandCandidatesPost>>, TError,{data: ExpandCandidatesApiGraphExpandCandidatesPostBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof expandCandidatesApiGraphExpandCandidatesPost>>, {data: ExpandCandidatesApiGraphExpandCandidatesPostBody}> = (props) => {
          const {data} = props ?? {};

          return  expandCandidatesApiGraphExpandCandidatesPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExpandCandidatesApiGraphExpandCandidatesPostMutationResult = NonNullable<Awaited<ReturnType<typeof expandCandidatesApiGraphExpandCandidatesPost>>>
    export type ExpandCandidatesApiGraphExpandCandidatesPostMutationBody = ExpandCandidatesApiGraphExpandCandidatesPostBody
    export type ExpandCandidatesApiGraphExpandCandidatesPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Expand Candidates
 */
export const useExpandCandidatesApiGraphExpandCandidatesPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof expandCandidatesApiGraphExpandCandidatesPost>>, TError,{data: ExpandCandidatesApiGraphExpandCandidatesPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof expandCandidatesApiGraphExpandCandidatesPost>>,
        TError,
        {data: ExpandCandidatesApiGraphExpandCandidatesPostBody},
        TContext
      > => {

      const mutationOptions = getExpandCandidatesApiGraphExpandCandidatesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Resolve Text
 */
export const resolveTextApiResolveTextPost = (
    resolveTextApiResolveTextPostBody: ResolveTextApiResolveTextPostBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.post(
      `/api/resolve/text`,
      resolveTextApiResolveTextPostBody,options
    );
  }



export const getResolveTextApiResolveTextPostMutationOptions = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resolveTextApiResolveTextPost>>, TError,{data: ResolveTextApiResolveTextPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof resolveTextApiResolveTextPost>>, TError,{data: ResolveTextApiResolveTextPostBody}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resolveTextApiResolveTextPost>>, {data: ResolveTextApiResolveTextPostBody}> = (props) => {
          const {data} = props ?? {};

          return  resolveTextApiResolveTextPost(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResolveTextApiResolveTextPostMutationResult = NonNullable<Awaited<ReturnType<typeof resolveTextApiResolveTextPost>>>
    export type ResolveTextApiResolveTextPostMutationBody = ResolveTextApiResolveTextPostBody
    export type ResolveTextApiResolveTextPostMutationError = AxiosError<HTTPValidationError>

    /**
 * @summary Resolve Text
 */
export const useResolveTextApiResolveTextPost = <TError = AxiosError<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resolveTextApiResolveTextPost>>, TError,{data: ResolveTextApiResolveTextPostBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof resolveTextApiResolveTextPost>>,
        TError,
        {data: ResolveTextApiResolveTextPostBody},
        TContext
      > => {

      const mutationOptions = getResolveTextApiResolveTextPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary  Healthz
 */
export const healthzHealthzGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `/healthz`,options
    );
  }


export const getHealthzHealthzGetQueryKey = () => {
    return [`/healthz`] as const;
    }

    
export const getHealthzHealthzGetQueryOptions = <TData = Awaited<ReturnType<typeof healthzHealthzGet>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthzHealthzGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthzHealthzGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthzHealthzGet>>> = ({ signal }) => healthzHealthzGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthzHealthzGet>>, TError, TData> & { queryKey: QueryKey }
}

export type HealthzHealthzGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthzHealthzGet>>>
export type HealthzHealthzGetQueryError = AxiosError<unknown>

/**
 * @summary  Healthz
 */
export const useHealthzHealthzGet = <TData = Awaited<ReturnType<typeof healthzHealthzGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthzHealthzGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getHealthzHealthzGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary  Readyz
 */
export const readyzReadyzGet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    return axios.get(
      `/readyz`,options
    );
  }


export const getReadyzReadyzGetQueryKey = () => {
    return [`/readyz`] as const;
    }

    
export const getReadyzReadyzGetQueryOptions = <TData = Awaited<ReturnType<typeof readyzReadyzGet>>, TError = AxiosError<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readyzReadyzGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadyzReadyzGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof readyzReadyzGet>>> = ({ signal }) => readyzReadyzGet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readyzReadyzGet>>, TError, TData> & { queryKey: QueryKey }
}

export type ReadyzReadyzGetQueryResult = NonNullable<Awaited<ReturnType<typeof readyzReadyzGet>>>
export type ReadyzReadyzGetQueryError = AxiosError<unknown>

/**
 * @summary  Readyz
 */
export const useReadyzReadyzGet = <TData = Awaited<ReturnType<typeof readyzReadyzGet>>, TError = AxiosError<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readyzReadyzGet>>, TError, TData>>, axios?: AxiosRequestConfig}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getReadyzReadyzGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




